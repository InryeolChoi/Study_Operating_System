# 5. 대체 방안

다중 쓰레드 응용을 좀 더 잘 할 수 있게 도움을 주는 다양한 기능을 보자.

# 트랜잭션 메모리

원래 데이터베이스에서 출발한 이론이지만, 프로세스 동기화 전략에도 응용.

트랜잭션 = 메모리 읽기와 쓰기의 원자적인 순서.

- 연산이 완수되면 확장 (commit)
- 그렇지 않다면 그 이전 상태로 되돌림 (roll-back)

이러한 기능을 프로그래밍 언어에 넣어서 동기화 전략에 응용.

```java
void update() {
	atomic {
		// modify shared data
	}

}
```

새 구조물 atomic이 update()에 추가되었다고 보자.

이 구조물은 내부 연산이 트랜잭션으로 실행된다는 것을 보장.

- 락이 전혀 사용 안됨 = 교착 상태가 불가능
- 공유 변수에 대한 병행 명령문을 구별.

주로 하드웨어나 소프트웨어를 통해 구현될 수 있다.

ex) 소프트웨어 트랜잭션 메모리(STM), 하드웨어 트랜잭션 메모리(HTM)

# OpenMP

- 컴파일러 디렉티브와 API로 구성됨.
- 컴파일러 디렉티브 `#pragma omp parallel` 이후에 등장하는 코드는 병렬구역으로 인식
- `#pragma omp critical` 이후의 코드는 임계코드로 판단.
    - 알아서 1회 1쓰레드 실행으로 설정.
    - 경쟁 조건을 알아서 차단.
- 표준 뮤택스 락을 더 쉽게 쓸 수 있지만, 개발자가 직접 임계구역을 찾아내야 함.
- 두 개 이상의 임계구역이 관여되면 여전히 교착상태 발생 가능

# 함수형 언어

변수가 정의되어 값을 배정받으면, 그 값은 변경될 수 없기 때문에 변하지 않음.

그래서 경쟁 조건이나 교착 상태를 신경 쓸 필요가 없다.