# 마스터파일
> 운영체제를 설계하는 방법을 다룬 문서

# 설계 및 구현
## 목적
운영체제를 만드는 목적을 생각해보자.

1. 사용자 목적
2. 시스템 목적

이 둘을 완벽하게 충족할 수는 없으나…

## 기법과 정책

한 가지 중요한 원칙은 있다. 바로 기법과 정책을 분리하는 것!

기법 : 어떻게 만들 것인가?

정책 : 무엇을 할 것인가?

ex. 타이머 보호

- 기법 : CPU 보호를 보장하기 위한 것.
- 정책 : 타이머를 얼마나 오랫동안 설정할 것인가?

## 구현

초기에는 어셈블리를 이용해 구현.

그러나, 요즘에는 c나 cPP를 이용하고, 그 외의 것도 사용한다.

# 운영체제 구조
운영체제의 구성요소들이 어떻게 상호 연결되는 지 살펴보자.

## 모놀리식 구조

단일 주소 공간에 커널의 모든 기능에 다 때려박는 방식.

- 전통적인 유닉스의 구현 방식이다.
- 단, 확장과 구현이 어렵다.
- 물론 커널 안의 통신 속도가 빠르고, 오버헤드가 거의 없다.
    - 오버헤드 : 어떤 명령어를 처리하는데 소비되는 간접적, 추가적인 컴퓨터 자원.

## 계층적 접근

최하층을 하드웨어, 최상층을 사용자 인터페이스로 잡는 방식

- 구현과 디버깅이 간단하다.
- 각 계층의 기능을 적절히 정의하는 것이 좀 힘들다.
- 사용자 프로그램이 여러 계층을 통과해야 하므로 오버헤드에 취약하다.
- 단, 현대의 운영체제는 이 설계 방식을 어느 정도는 따르고 있다.

## 마이크로 커널

유닉스가 커짐에 따라 모놀리식을 적용하기 힘들어지자 등장한 방식.

커널에서 필요없는 부분을 제거한 뒤 사용자 수준으로 넘긴다.

커널에 보통 남는 것은 통신, 최소한의 프로세스, 메모리 관리이다.

### 장점

- 운영체제의 확장이 쉽다.
- 모든 서비스가 사용자 공간에 추가되기 때문에, 커널을 변경할 필요가 없다.
- 다른 하드웨어로의 이식이 쉽다.
- 한 서비스가 잘못되어도, 운영체제의 다른 부분은 영향을 안 받는다.

### 단점

가중된 시스템 기능 오버헤드 때문에 성능이 나빠진다.

- 두 개의 사용자 수준 서비스가 통신해야 하는 경우 별도의 주소 공간에 서비스가 존재하기 때문에 메세지가 복사되어야 한다.
- 메세지를 교환하기 위해 한 프로세스에서 다음 프로세스로 전환해야 할 수도 있다.

### 예시

- iOS, macOS, watchOS 등에 들어가는 Darwin 커널이 마이크로커널 운영체제이다.
- 실시간 운영체제 QNX

## 모듈

- 가장 최신 기술.
- 커널은 핵심적인 구성요소의 집합을 가지고, 부팅 때나 실행 중에 부가적인 서비스들을 모듈을 통하여 링크할 수 있다.
- 커널은 핵심 서비스를 제공하고, 다른 서비스들은 커널이 실행되는 동안 동적으로 구현

## 하이브리드 시스템

- 오늘날의 운영체제는 사실 앞의 4가지 방식을 혼합한 것이다.

### iOS의 구조

1. 사용자 경험 층
2. 응용프로그램 프레임워크 층
3. 핵심 프레임워크
4. 커널 : 다윈

### Darwin의 구조

1. 라이브러리 인터페이슨
2. Mach 트랩 & BSD 시스템 콜
3. 기본 운영체제 서비스
    (이 기능은 대부분 커널 추상화를 통해 사용 가능)

# 운영체제 빌딩과 부팅
## 운영체제 생성

1. 운영체제 소스코드를 작성
2. 시스템의 운영체제 구성
3. 컴파일
4. 설치
5. 부팅

## 부팅

부팅의 과정을 알아보자.

1. 부트로더가 커널의 위치를 찾는다.
2. 커널이 메모리에 적재되고 시작된다.
3. 커널은 하드웨어를 초기화한다.
4. 루트 파일 시스템이 마운트된다.

다단계 부팅 과정을 사용하는 경우도 있다.

- 과거에는 BIOS, 오늘날에는 UEFI
- 리눅스에선 GRUB
- 모바일은 조금 다른 과정

또한 모든 운영체제의 부트로더는 복구모드나 단일 사용자모드로 

부팅할 수 있는 기능을 제공한다.


# 운영체제 디버깅
## 디버깅이란?

하드웨어와 소프트웨어에서 시스템의 오류를 발견하고, 수정하는 행위

## 장애 분석

프로세스가 실패한다면, 이를 로그 파일에 기록.

프로세스가 사용하던 메모리를 캡쳐한 코어 덤프를 취하고 차후 분석을 위해 파일로 저장한다.

## 성능 관찰 및 조정

병목 지점을 제거함으로써 성능을 향상하는데 초점을 둔다.

병목 지점을 찾기 위해서는 시스템 성능을 감시해야 하는데, 이때 쓰이는 도구는 

두 가지의 접근 방식을 쓸 수 있다.

### 1. 카운터

운영체제는 카운터를 통해 호출된 시스템 콜 횟수, 장치, 작업수를 본다.

ps, top, vmstat, netstat 등이 대표적인 명령어이다.

대부분의 카운터 기반 도구는 /proc 파일 시스템에서 통계를 읽는다.

이는 커널 메모리에서만 존재하는 의사(pseudo) 파일 시스템이다.

프로세스는 /proc 의 하위 디렉토리로 표기.

### 2. 추적

특정 이벤트에 대한 데이터를 추적한다.

strace, gdb, perf, tcpdump 등이 대표적.

### 3. BCC

리눅스 시스템을 위한 추적 기능을 제공하는 툴킷.

- 실행 중인 리눅스 시스템에 동적으로 삽입될 수 있다.
- 특정 이벤트를 캡처 하거나 시스템 성능을 관찰하는데 사용될 수 있음.