# 운영체제의 구조

태그: 1장

# 큰 그림 보기

![Untitled](./참고파일/3_운영체제의_구조/Untitled.png)

# 서비스

운영체제는 서비스를 제공한다. 운영체제마다 제공하는 서로 다른 서비스들이 존재하지만, 그 중 공통된 것을 뽑아보자면 다음과 같다.

- 사용자 인터페이스
- 입출력 연산
- 파일 시스템 조작
- 통신
- 오류 탐지

일부 서비스는 시스템 자체의 효율을 위해 쓰인다.

- 기록 작성
- 보호와 보안

# 사용자와 인터페이스

- 자원 할당

사용자와 운영체제가 서로 접속하기 위해서는 어떠한 규격, 인터페이스가 필요하다.

이러한 사용자 인터페이스(UI)에는 다양한 종류가 있다.

## 1. 명령 인터프리터 (CLI)
* 글자를 직접 쳐서 운영체제에 명령을 방식. 쉘(shell)이라고도 한다.
* 명령어의 구현
1. 명령 인터프리터 자체가 명령을 실행할 코드를 가지는 경우
2. 시스템 프로그래밍에 의해 대 부분의 명령을 구현하는 경우

1번 케이스의 경우,
- 명령 인터프리터가 자신의 코드의 한 부분으로 분기
- 그 코드 부분이 매개변수를 설정하고 시스템 콜을 한다.

2번 케이스의 대표적인 예시는 다음과 같다.
```bash
rm new.txt
```
- rm이라는 파일을 찾아서, 그 파일을 메모리에 적재하고
- 그것을 매개변수 new.txt로써 수행한다.
- rm의 의미, 즉 파일을 지우는 로직은 rm이라는 파일의 코드에 담겨있다.

## 2. 그래픽 인터페이스 (GUI)
### GUI : 개요

- 마우스, 터치스크린 등을 이용해 운영체제와 접촉하는 것.
- 1970년대 제록스 연구소에서 시작

### 선택과 집중

- 좀 더 빠르고 효율적으로 명령을 내리려면 CLI가 적합
- 사용하기 쉬운 쪽을 택한다면 GUI가 적합


# 시스템 콜

**운영체제에 의해 사용가능한 서비스**에 대한 인터페이스를 제공.

운영체제만 할 수 있는 기능.

일반적으로 c나 cpp로 작성된 형태로 제공된다.

## 예시 : 시스템 콜

```bash
cp in.txt out.txt
```

`cp` : 첫 번째 매개변수의 내용을 두 번째 매개변수로 복사(copy)하는 명령어

이를 실행하려면 여러가지 시스템 콜이 필요하다.

- 열기
- 닫기
- 에러 메세지 출력
- 비정상적 종료
- 프로그램 중단
- 등등…

## 시스템 콜과 API

위에서 보여지듯, 간단한 프로그램을 작성해도 시스템 콜은 많이 필요하다.

그래서, 이를 하나하나 알기 불편하기에 API, 응용 프로그래밍 인터페이스를 만들었다.

API의 숨겨진 부분에는 시스템 콜이 있다.

예를 들어, 리눅스의 API인 read() 함수를 보자.

```bash
man read
```

```c
#include <unistd.h>

ssize_t read(int fd, void *buf, size_t count)
```

API는 다음과 같은 이점이 있다.

1. API를 지원하는 어느 시스템에서든 컴파일되고 실행될 수 있다.
    
    시스템 콜만을 불러서 하기에는 컴퓨터 구조의 차이 때문에 쉽지 않다.
    
2. 시스템 콜은 API보다 다루기 어렵다.

시스템 콜을 다루는데 있어서 중요한 또 다른 요소는 **실행시간 환경(RTE)**이다.

<aside>
💡 실행시간 환경 : 특정 언어로 작성된 프로그램을 실행할 때 필요한 전체 제품.

</aside>

RTE는 시스템 콜과 언어를 연결시켜주는 인터페이스를 가지고 있다.

## 시스템 콜의 유형
### 프로세스 제어 시스템 콜
대표적인 프로세스 제어를 예시로 들어보자.

- 프로그램을 정상적으로 멈추게 하기 : `end()`
- 프로그램을 비정상적으로 멈추게 하기 : `abort()`
- 오류 트랩을 유발할 때 : `trap()`
- 프로세스가 다른 프로그램을 적재 : `load()`
- 실행하기 : `execute()`

### 파일관리 시스템 콜
대표적인 파일관리 시스템 콜을 알아보자.
- 파일을 생성 : `create()`
- 파일을 삭제 : `delete()`
- 파일을 열고 : `open()`
- 파일을 쓰고 : `write()`
- 파일을 닫기 : `close()`

### 장치관리 시스템 콜
프로세스는 작업을 계속 수행하기 위해 추가 자원이 필요할 수 있다.

따라서 이 경우에는 다음과 같은 시스템 콜을 생각할 수 있다.

- 장치를 요청 : request()
- 장치를 방출 : release()

### 정보 유지 관리 시스템 콜
어떠한 시스템 콜은 사용자 프로그램과 운영체제 간의 정보전달에 쓰임.
- 시간, 날짜, 메모리 덤프

### 통신 시스템 콜
통신 모델에는 메시지 전달과 공유 메모리가 있다.

**메세지 전달**
두 프로세스가 정보를 교환하여 서로 메세지를 주고 받는다.

- get_hostid()
- get_processid()
- read_message()
- write_message()

**공유 메모리 기능** 

한 프로세스가 다른 프로세스가 소유한 메모리 영역에 접근

- shared_memory_create()
- shared_memory_attach()

## 보호
컴퓨터 시스템이 제공하는 자원에 대한 접근을 제어하기 위한 기법을 지원

- set_permission
- get_permission


# 시스템 서비스 (유틸)

시스템 서비스는 프로그램 개발과 실행을 위해 더 편리한 환경을 제공한다.

하드웨어 → 운영체제 → 시스템 서비스 수준이 순으로 올라간다.

다음과 같은 범주로 구분할 수 있다.

시스템 콜에 대한 사용자 인터페이스인 것도 있고, 더 복잡한 것도 있다.

- 파일 관리 : 파일과 디렉토리를 생성, 삭제, 복사, 개명한다.
- 상태 정보 : 시스템의 상태 정보를 확인 및 등록해준다.
- 파일 변경 : 파일의 내용을 생성하고, 변경하기 위해 다수의 텍스트 에디터를 사용할 수 있다.
- 프로그래밍 언어 지원 : 다양한 프로그래밍 언어의 컴파일러를 제공하거나 다운받는다.
- 프로그램 적재와 수행 : 일단 프로그램이 실행되면 이를 꼭 메모리에 적재해야 하는데, 시스템은 절대 로더, 배치 가능로더 등을 제공할 수 있다.
- 통신 : 프로세스, 사용자, 타 컴퓨터 시스템 사이에 가상접속을 위한 기법을 제공한다.
- 백그라운드 서비스 : 일부 프로세스는 시스템이 정지할 때까지 계속 실행되는데, 이를 서비스, 서브시스템, 데몬이라고도 부른다.

# 링커와 로더, 그리고 프로그램

## 링커와 로더

프로그램의 실행 순서를 살펴보자.

1. 소스 프로그램 → 컴파일러 → 오브젝트 파일
2. 여러개의 오브젝트 파일을 묶어 바이너리 파일로 바꾸는 프로그램을 **링커**라고 한다. 
3. 바이너리 파일을 메모리에 적재시키는 것을 **로더**라고 한다.

```bash
# 링커의 예시
gcc -o main main.o -lm 

# 로더의 실행 예시 (밑에 좀 더 자세한 설명이 있다.)
./main
```

Unix 시스템에서 프로그램 이름을 입력하면..

1. fork() 시스템 콜로 새 프로세스를 만든다.
2. exec() 시스템 콜로 로더를 호출하고, 프로그램 이름을 매개변수로 보낸다.
3. 로더는 새로 생성된 프로세스의 주소 공간을 사용해 지정된 프로그램을 메모리에 적재한다.
4. 프로그램이 실행!

위의 가정은 모든 라이브러리가 실행 파일에 링크되어 메모리에 적재된다고 가정한 것이다.

실제로는, 프로그램이 실행될 때 라이브러리를 동적으로 링크할 수 있게 한다.

- 링커가 재배치 정보를 삽입해 필요한 라이브러리만 링크할 수 있게 해 준다.
- 이 방식을 이용해 메모리 낭비를 줄인다.

오브젝트 파일과 실행파일은 일반적으로 표준화된 형식을 가진다.

이는 컴파일된 기계 코드 및 프로그램에서 참조되는 함수/변수의 메타데이터를 포함하는 

기호 테이블을 포함한다.

- 리눅스/유닉스에선 이를 ELF라고 한다.
- 맥에서는 이를 Mach-O라고 한다.

## 크로스 플랫폼과 앱

인제 슬슬 이 질문에 답을 할 수 있을 것이다.

<aside>
💡 동생(15세) : 왜 pc용 메이플스토리를 아이패드에선 못하는 거야?!

</aside>

1. 운영체제마다 시스템 콜이 다르다.
2. 그래서 운영체제마다 제공하는 API가 다르기 때문에, 윈도우용 API를 
    
    ios에선 지원하지 않는다.
    
3. 시스템의 낮은 수준에서 보자면
    - 운영체제마다 정해진 응용프로그램 이진 형식이 있다.
        
        이를 어기면 파일이 열리고, 프로그램이 적재되는 과정이 안된다. 
        
    - CPU마다 명령 집합이 다르다. (X86 vs ARM)
    - 시스템 콜이 운영체제마다 다르다.

이를 해결하기 위해…

- 모든 리눅스, 유닉스의 바이너리 파일은 ELF 형식을 채택
    - 단, ELF 형식은 특정 컴퓨터 아키텍쳐와 연관이 없으므로 100% 호환성을 보장하지는 않는다.
    - 즉, 같은 리눅스여도 인텔 i7냐 ARM m2 칩이냐에 따라 달라질 수 있다.
- 아키텍쳐 수준의 API를 ABI라고 한다.
    - 그러나 ABI는 호환성을 제공하지 않는다.

따라서 특정 CPU유형의 특정 운영체제에서 인터프리터, RTE, 바이너리 파일을 작성하고 컴파일 하지 않으며 응용 프로그램이 실행되지 않는다.

→ pc용 메이플을 헤집고 뜯어 고쳐야 아이패드용이 된다는 뜻…

# 운영체제 만들고 실행하기
[마스터플랜](./참고파일/마스터파일.md)