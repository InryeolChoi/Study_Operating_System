# 8. NFS

## NFS란?

- 클라이언트-서버 네트워크 파일 시스템의 한 예시.
- LAN을 거쳐 원격 파일에 접근하기 위한 소프트웨어 시스템의 구현과 명세
- 대부분의 업체가 지원하는 ONC+의 일부
- 책에서는 버전 3을 기준으로 설명

## NFS의 연결 방식

서로 다른 워크스테이션의 집합을 독립적인 기계들의 집합으로 간주.

NFS는 이들 간의 파일 공유를 일정 수준 투명하게 허용하는 것.

- 공유는 한 쌍의 기계 사이에서 이뤄진다.
- 한 서버가 클라이언트도, 서버도 될 수 있다.
- 공유는 클라이언트에게만 영향을 미친다.

### 연결 과정

특정 시스템 m1이 원격 디렉터리에 투명하게 접근하려면

1. m1의 클라이언트가 먼저 마운트 명령을 수행
    
    원격 디렉토리가 로컬 파일 시스템의 디렉터리 상에 마운트됨.
    
2. 마운트된 디렉토리 = 로컬 디렉토리의 하부 트리
    
    마운트 명령을 위한 매개변수로 원격 디렉터리를 지정하려면, 반드시 원격 디렉터리의 위치가 제공되어야 함.
    
    그러나 일단 마운트가 되고 나면 이 과정이 필요 없음.
    

### 예시

마운트 전 각각의 독립적인 파일 시스템

![IMG_0229.jpeg](8%20NFS%204a36f62cc34140d68f8211f19cf43fc5/IMG_0229.jpeg)

마운트 후의 파일 시스템의 모습

![IMG_0230.jpeg](8%20NFS%204a36f62cc34140d68f8211f19cf43fc5/IMG_0230.jpeg)

삼각형 : 디렉터리의 하부 트리를 의미

마운트 완료 후에는 `/usr/local/dir1`을 사용해 `dir1` 속 파일에 접근 가능

원래 볼륨 U에 있던 로컬 파일에는 더이상 접근할 수 없음.

접근 권한만 있다면 어느 파일 시스템, 디렉터리이든 원격으로 마운트 할 수 있음.

일부 NFS 구현에는 연속 마운트 또한 허용됨. 

- 즉 한 파일 시스템이 원격 마운트된 파일 시스템에 다시 마운트 될 수 있음.

한 기계는 단지 자신이 호출한 마운트에 의해서만 영향을 받음.

원격 파일 시스템을 마운트해도 클라이언트는 그 전에 마운트되어 있던 다른 파일 시스템에는 접근 불가.

### 연속 마운트

앞의 15.7의 그림 (b)를 보면 연속 마운트가 나온다.

해당 그림은 `U:/usr/local/dir1`에 `S2:/usr/dir2`를 마운트한 결과

- `/usr/local/dir1` 은 이미 마운트되어 있는 상황.
- 만약 공유된 디렉터리를 네트워크 상 모든 기계의 사용자 홈 디렉터리에 마운트한다면, 사용자는 모든 워크스테이션에 로그인하여 자신의 홈 환경을 가질 수 있음.
- 이러한 특성은 사용자 이동성을 허용

### NFS의 설계 목표

- 이질적 환경에서 작동하도록 하는 것.
- NFS 명세는 이들 매체에 독립적이기 때문에 다른 구현을 이용 가능
- 독립성은 2개의 구현 독립적 인터페이스 간에 사용되는 외부 자료 표현(XDR) 프로토콜 위에 구축되는 RPC 프리미티브를 통해서 이뤄짐.
- 따라서 NFS와 정확하게 인터페이스되는 시스템에선 다른 유형의 파일 시스템을 마운트할 수 있음.

NFS 명세는 마운트 기법에 의해 제공되는 서비스와 실제 원격 파일 접근 서비스를 구분

- 마운트 기법에 의해 제공되는 서비스 ⇒ 마운트 프로토콜
- 실제 원격 파일 접근 서비스 ⇒ NFS 프로토콜
- 이 프로토콜은 RPC 집합으로 명시되어 있음.
    - RPC = 투명한 원격 파일 접근 구현을 위해 사용되는 빌딩 블록

## 마운트 프로토콜

<aside>
💡 서비스와 클라이언트 사이 초기 논리적 연결을 생성하기 위해서 사용

</aside>

- 마은트 명령 : 마운트 대상인 디렉터리의 이름 + 서버 기계의 이름을 포함
- 마운트 요구는 적절한 RPC로 매핑 → 지정된 서버 기계 상에서 수행되는 마운트 서버로 전송
- 서버는 수출 리스트를 유지
    - 이는 그들을 마운트할 수 있도록 하는 기계 이름 + 마운트 가능한 로컬 파일 시스템을 지정
    - 읽기 전용 등 접근 권리를 포함할 수 있음.
    - 수출 리스트 & 마운트 테이블의 유지 관리를 단순화하기 위해 분산 네이밍 기법 사용가능.
- 서버가 마운트 요구를 받으면, 클라이언트에게 파일 핸들을 반환
- 또한 클라이언트 시스템의 리스트와 각 시스템에 현재 마운트된 디렉터리를 유지.
    - 이는 관리 목적을 위해 사용됨.
    - 여기에 항목을 추가/삭제하는 것이 마운트 프로토콜이 서버 상태에 영향을 주는 유일한 방법
- 일반적으로 시스템은 미리 정해진 정적 마운트 구성을 가지고, 이는 변경될 수 없음.
- 마운트 프로토콜은 실제적인 마운트 프로시저 외에도 다른 여려 프로시저를 가지고 있음.

## NFS 프로토콜

<aside>
💡 원격 파일 연산을 위한 원격 프로시저 호출의 집합을 제공.

</aside>

원격 파일 연산을 위해 다음 연산을 제공

- 검색, 디렉터리 내 읽기, 파일 속성의 접근, 링크와 디렉터리들의 조작 등등
- 원격으로 마운트된 디렉토리에 대한 파일 핸들이 있을 때 호출할 수 있음.

**NFS 서비스의 주요 특징 = 무상태성**

- 서버는 두 접근 사이에 클라이언트에 대한 정보를 유지하지 않음.
- 서버에 파일구조와 비슷한 구조가 존재하지 않음
- 각각의 요구는 매개변수들의 완전한 집합을 제공
    - 견고성을 증진할 수 있는 방식
    - 따라서 파일 연산은 같은 동작을 여러 번 수행해도, 한 번만 실행되어야 함 (멱등성)
- 클라이언트 리스트는 유지되나, 이는 무상태성 유지를 위한 조건은 아님

서버의 무상태성 & RPC의 동기성 = 클라이언트에게 반환 전 변경된 자료가 기록되어야 함.

- 클라이언트가 쓰기 블록들을 캐시할 순 있으나, 그것들을 서버로 쏟아낼 때는 이미 서버의 디스크에 반영된 것으로 가정.
- 서버는 모든 NFS 데이터를 동기적으로 써야만 함.
    - 따라서 서버의 크래시는 직접적으로 보이지 않음.
    - 단 성능의 문제가 생길 수 있음. 캐싱의 장점을 얻지 못하기 때문
    - 이 문제를 캐시를 갖는 저장장치로 해결
    - 이를 통해 빠른 동기식 쓰기를 할 수 있음.
- 하나의 NFS 쓰기 프로시저 호출은 원자성이 보장, 같은 파일에 대한 다른 쓰기 호출과 혼합되지 않음
    
    그러나 NFS는 병행성 제어 기법을 제공하지 않음. 즉, 두 사용자의 데이터가 뒤섞일 수도 있음.
    
- 그래서 사용자들은 NFS와는 별개의 기법으로 공유 파일에 대해 서로 협력하면서 접근해야 함.

**NFS와 운영체제**

NFS는 VFS(가상 파일 시스템)을 통해 운영체제에 통합됨.

![IMG_0231.jpeg](8%20NFS%204a36f62cc34140d68f8211f19cf43fc5/IMG_0231.jpeg)

1. 클라이언트는 시스템 콜로 연산 시작
2. 운영체제 층은 이 호출을 적절한 VFS 연산으로 매핑
3. VFS는 이 파일을 원격 파일로 인식 & 적절한 VFS 프로시저를 실행
4. 하나의 RPC 호출이 원격 서버 내의 NFS 서비스 계층에 대해 행해짐
5. 이 호출이 원격 시스템 상의 VFS 계층으로 들어가고, 연산 실행
6. 결과 반환

시스템이 클라이언트/서버 모두가 될 수 있음.

각 서버 속 실제 서비스는 경량 프로세스에 의해서 실행됨.

## 경로 이름 변환

파일 이름은 다음과 같은 3가지로 이뤄진다.

```c
/usr/local/dir/file1.txt

usr, local, dir
```

경로 이름 변환은 다음과 같이 이뤄짐.

1. 경로를 구성요소 이름으로 분리
2. 구성요소 이름과 디렉터리 vnode의 모든 쌍에 대한 별도의 NFS 룩업 호출 실행

일단 마운트 포인터를 넘어가면, 모든 구성요소 룩업은 서버에 대한 별도의 RPC를 유발

- 비용이 많이 들 수 밖에 없음
- 클라이언트가 어떻게 마운트 했느냐에 따라 각 논리적 이름 공간이 다 다르기 때문

룩업을 더 빠르게 하기 위해서, 클라이언트 측의 디렉터리 이름 룩업 캐시는 원격 디렉터리 이름에 대한 vnode를 가지고 있음.

- 해당 캐시는 시작 부분이 같은 경로 이름을 가진 파일들에 대한 참조 속도를 증가
- 만약 서버로부터 반환된 속성들이 vnode와 일치하지 않으면 버림.

## 원격 연산

유닉스의 시스템 콜 ↔ NFS의 RPC 시스템 콜 : 거의 1대1 대응 관계

따라서 원격 파일 연산은 대응되는 RPC로 직접 변환 가능.

개념적으로 NFS는 원격 서비스 패러다임을 따르지만, 실제로는 캐싱과 버퍼링을 사용

원격 연산이 RPC와 직접 대응되지는 않지만, 파일 블록과 파일 속성이 RPC에 의해서 인출되며, 지역에 캐시

그 뒤의 원격 명령들은 일관성 제한이 허락하는 한 캐시 자료를 사용.

캐시 형태는 크게 2가지.

1. 파일 블록 캐시
2. 파일 속성 캐시

파일 오픈 시 : 커널은 캐시된 속성을 다시 가져올지, 또는 이전 것을 다시 사용할지 결정하기 위해 검사.

- 대응되는 캐시된 속성들이 최신 버전일 때만 사용.
- 서버로부터 새 속성들이 도착될 때마다 캐시된 속성이 갱신됨.
    - 캐시된 속성들은 디폴트로 60초 후에 버림.
- 클라이언트-서버 간에는 read-ahead & delayed-write 기법이 모두 사용됨.

성능을 위한 시스템 조정 = 일관성 의미를 규정하기 어렵게 만듬.

그럼에도 기법의 효율성과 고성능 때문에 오늘날까지도 사용.