# 3. 파티션과 마운팅

## 디스크와 파티션

디스크의 배치는 운영체제와 볼륨 관리자 소프트웨어에 따라 크게 달라짐

- 디스크는 여러 파티션으로 분할될 수 있음 ⇒ 여기서 다룸.
- 또 한 파티션이 여러 디스크로 구성될 수도 있음. ⇒ RAID

### 파티션의 종류

각 파티션은 크게 2개로 나눌 수 있음.

- raw 파티션 : 파일 시스템이 포함되지 않음.
- cooked 파티션 : 파일 시스템이 포함됨.

### raw 디스크

raw 디스크는 파일 시스템이 사용되지 않는 곳에 사용됨.

- 유닉스의 스왑 공간 : 디스크 상에 자신의 고유 포맷 사용
- 데이터베이스 : 데이터를 데이터베이스의 요구에 맞게 포맷
- RAID 시스템에 필요한 정보 저장
    - 어느 블록이 mirrored 되었는지 가리키는 비트맵 저장
    - 어느 블록이 변경되어 mirrored 될 필요가 있는지 가리키는 비트맵 저장
- 축소형 데이터베이스 : 어느 디스크가 RAID 세트의 멤버인지 가리킴.

## 부트로더

파티션에 부팅 가능한 시스템이 포함되어 있는 경우, 파티션은 부팅 정보도 필요함.

부팅 중에 시스템은 적재된 파일 시스템 코드가 없고, 따라서 파일 시스템 형식을 해석할 수 없음.

그래서 부팅 정보는 자체적인 형식을 가짐. (보통 이미지처럼 메모리에 적재되는 연속된 블록)

이러한 이미지를 **부트스트랩 로더, 또는 줄여서 부트로더** 라고 함.

부트스트랩 로더는 첫 번째 바이트처럼 미리 정해진 위치에서 시작함.

커널을 찾아서 적재하고, 실행을 시작할 수 있을 만큼 파일 시스템 구조에 대해서 잘 알고 있음.

### 부트로더의 특징

특정 운영체제를 부트할 수 있는 명령어 이상을 포함하고 있음.

ex. 이중 부팅을 통한 2개 이상의 운영체제 지원 (intel Mac의 bootcamp)

- 여러 파일 시스템과 여러 운영체제를 인식하는 부트 로더가 부트 공간을 점유
- 일단 적재되면, 그 드라이브에서 이용 가능한 운영체제 중 하나를 부트할 수 있음.

드라이브는 여러 파티션을 가질 수 있는데, 각 파티션이 다른 파일 시스템과 운영체제를 포함할 수도 있음.

- 부트로더가 특정 파일 시스템 형식을 이해하지 못하면 해당 파일 시스템에 저장된 운영체제는 부팅 못함.
- 운영체제에서 일부 파일 시스템만 루트 파일 시스템으로 사용하는 이유

루트 파티션은 부팅을 시작할 때 마운트 됨.

다른 파티션은 부트 시에 자동으로 마운트. 또는 부팅 이후 운영체제에 의해 마운트

마운트 연산 중 운영체제는 시스템이 유효한 파일 시스템을 가지고 있는지 파악

1. 운영체제는 장치 드라이버에게 장치 디렉터리를 읽도록 요청
2. 이를 통해 디렉터리가 유효한 포멧을 가졌는지 확인함.
    - 포맷이 유효하지 않다면, 사용자의 중재에 기반
    - 이 과정을 통해 유효한 파일 시스템을 가졌는지 파악
    - 또는 중재 없이 파티션의 일관성을 검사 후 바로잡으려고 함
3. 운영체제는 메모리에 존재하는 마운트 테이블에 다음 2가지를 기록
    - 파일 시스템이 마운트 되었다는 사실
    - 파일 시스템의 유형

## 예시 : Windows

각각의 파티션을 문자와 콜론으로 명시된 다른 namespace에 마운트

ex. 파일 시스템이 `F:` 에 마운트 되었을 때

➡️ `F:` 에 대응되는 장치 구조의 한 필드에 파일 시스템 포인터를 기록

프로세스가 드라이브 문자를 지정하면 운영체제는 적절한 파일 시스템 포인터를 찾음

이후 지정된 파일/디렉토리를 찾기 위해 그 장치 상의 디렉터리 구조를 탐색

## 예시 : Unix

파일 시스템은 어떠한 디렉토리에도 마운트될 수 있음.

➡️ 그 디렉터리의 메모리 내 inode의 한 플래그를 설정함으로써 구현

➡️ 플래그는 디렉터리가 마운트 포인트임을 가리킴.