# 6. 효율과 성능

블록 할당 기법 & 디렉터리 관리 기법들은 저장장치의 성능과 효율성에 어떠한 영향을 미치는가?

저장장치는 컴퓨터 시스템 중 가장 느려서 병목을 일으키기 쉬운 부분. 따라서 이에 대한 최적화 역시 필요함.

# 효율성

저장장치의 효율성 개선은 할당 및 디렉터리 알고리즘과 밀접한 관련이 있음

1. 유닉스의 i-node
    1. 한 파티션 (빈 디스크의 일부 포함)에는 i-node가 할당되어 있음
    2. i-node를 미리 할당 & 파티션 전체에 분산 하면 파일 시스템의 성능 향상 가능
    3. i-node를 가급적 데이터 블록 부근에 위치시켜 검색 시간 향상
2. 클러스터링 기법
    1. 내부 단편화 허용 but 파일 탐색 및 전송 속도 향상
    2. 내부 단편화 최소를 위해 파일 크기가 증가하면 클러스터 크기도 변화시킴

**파일의 디렉터리나 i-node에 저장되어야 할 정보의 종류도 고려해야 함**

ex. 파일의 마지막 쓰기 시각 기록

- 보통 백업용으로 많이 사용함
- 그런데, 이러한 기록은 파일을 불러올 때마다 읽히게 됨
- 여기서 생기는 오버헤드도 고려해야 함

ex. 포인터의 크기

- 64비트 포인터 사용 시 파일 크기가 커짐
    - 그런데 포인터를 저장하기 위해서는 더 많은 공간을 소모
    - 할당 및 가용 공간 관리 과정이 더 많은 공간을 사용
- 포인터 크기를 선택하거나 할당 크기를 고정할 때는 기술변화를 대비해야 함
    - 초기의 파일 시스템 : 효율성을 위주로 결정
    - 이후 하드웨어 발달에 따라 효율성이 최우선적인 가치는 아니게 됨
    - 이로 인한 컴퓨터 시스템의 변경이 문제가 됨
- 초기 운영체제 : 데이터 구조의 길이가 고정되어 시스템 시동 시 할당.
    - 프로세스 테이블이 만원이 되면 파일 오픈이 안됨
- 현대 운영체제 : 커널 구조가 동적으로 할당
    - 시스템 성능에 대한 제약이 사라지게 됨
    - 물론 동적 할당을 제어할 알고리즘을 도입해야 했음.

# 퍼포먼스

기본적인 파일 시스템 알고리즘이 결정되어도, 시스템 성능을 향상시킬 방법을 알아보자.

1. 통합 가상 메모리
    1. 가상 메모리 기법으로 파일 데이터를 페이지 캐시를 사용해 캐시하는 것
        
        물리 메모리로 파일 데이터를 캐시 하는 것보다 더 효율적인 기법
        
    2. 페이지 캐시 = 파일 데이터를 가상 주소로 캐시하는 것.
2. 통합 버퍼 캐시
    1. 메모리 맵드 입출력과 시스템 콜(read, write)가 같은 페이지 캐시를 사용하게 하는 것
    2. 유닉스의 몇 가지 종류에서 제공함
    3. 이중 캐싱(버퍼 캐시에 있는 파일이 페이지 캐시로 계속 복사되는 현상)을 극복.
3. 솔라리스의 사례
    1. 버전 5 : 프로세스나 페이지 캐시 모두 같은 페이지 할당을 사용. 메모리가 페이지 캐싱에만 빈번히 사용됨.
    2. 버전 7: 선택 사항으로 우선순위 페이징 제공. 페이지 스캐너가 페이지 캐시보다 프로세스 페이지에 우선순위 부여
    3. 버전 8 이후 : 프로세스 페이지와 파일 시스템 페이지 사이의 고정된 한계 설정
    4. 최신 : 메모리 사용량 최대화, 쓰레싱 최소화
4. 쓰기 연산의 동기화 : 쓰기 연산이 파일 시스템에 동기적으로 수행되는가?
    1. 동기식 쓰기 : 저장장치 서브시스템이 요청을 받은 순서로 이뤄지고, 쓰기가 버퍼에 저장되지 않는다.
        
        호출 루틴이 데이터가 디스크 드라이브에 도착한 후에야 수행을 계속할 수 있음
        
        메타데이터 작업을 동기식 쓰기로 함.
        
        동기식 쓰기를 위한 플래그가 존재.
        
    2. 비동기식 쓰기 : 데이터를 캐시에 저장하고, 호출자에게 제어를 돌려줌
        
        대부분의 작업은 비동기식 쓰기로 이뤄짐.
        
5. 파일의 유형에 따른 교체 알고리즘
    1. 순차적으로 읽히고 쓰이는 파일 : LRU 순서에 따라 교체되어서는 안됨
        
        대부분 최근 사용 페이지는 마지막으로 사용되었거나 사용되지 않았기 때문
        
    2. 순차 파일 최적화 1 : Free-behind
        
        다음 페이지가 요청되자마자 버퍼에서 페이지를 제거
        
    3. 순차 파일 최적화 2 : read-ahead
        
        요구된 페이지와 이후 페이지 몇 개를 읽어 캐싱
        
        일부러 이후 페이지를 읽어서 시간을 단축.
        

페이지 캐시, 파일 시스템, 장치 드라이버의 상호작용이 중요.

- 페이지는 캐시에 버퍼되고, 장치 드라이버는 자신의 출력 큐를 장치 주소에 따라 정렬
    - 디스크 헤드 탐색을 최소화
- 동기식 쓰기가 필요 없을 때, 쓰기를 할 프로세스는 단순히 캐시에 쓰고, 시스템은 편리할 때 비동기식으로 데이터를 씀.
    - 사용자가 매우 빠르게 쓰기 작업을 할 수 있음
- 블록 입출력 시스템은 약간의 미리 읽기 작업을 수행
    - 쓰기 작업이 읽기보다 비동기식에 적합한 작업
    - 대규모 전송의 경우 출력이 입력보다 빠름
- 대규모 연속 I/O는 장치 성능에 병목 발생시킬 수 있음.