# 10. 운영체제별 예시

## 리눅스

- 요구 페이징을 사용해 가용 프레임 리스트에서 페이지를 할당
- LRU 근사 클록 알고리즘과 유사한 전역 페이지 교체 정책을 사용
- 메모리 관리를 위해 active_list와 inactive_list를 유지 관리.
    - active_list : 사용 중인 것으로 간주하는 페이지 포함
    - inactive_list : 최근에 참조되지 않고, 회수할 수 있는 페이지가 포함.
- 각 페이지에는 accessed 비트가 존재
    - 처음 할당될 때 active_list의 끝에 추가.
    - 주기적으로 이 비트는 리셋.
    - 결국 가장 참조 안된 페이지가 active_list의 맨 앞에 있게 됨.
- 두 리스트는 균형을 이룸.

## 윈도우

- 인텔 및 ARM에서 실행되는 32비트 및 64비트 지원.
- 클러스터링이 가미된 요구 페이징 사용하면서 가상 메모리 구현
    - 클러스터링 = 메모리 참조의 지역성을 인지하는 전략
    - 페이지 폴트가 발생한 페이지 + 앞뒤 페이지를 함께 메모리로 읽어드림
- 가상 메모리 관리의 주요 구성요소는 작업-집합 관리
    - 한 프로세스 당 50~345페이지의 작업-집합이 지정됨.
    - 50 = 최소 페이지 갯수로 생각하면 됨.
    - 메모리가 충분하면 이 작업-집합의 값을 무시하고 할당할 수도 있음.
- LRU 근사 클록 알고리즘을 사용
- 가용 메모리양이 너무 떨어지면 “자동 작업-집합 트리밍”을 이용해 (일종의 전역 교체 전술) 메모리를 체움.
    - 사용자 모드와 시스템 모드 모두 작업-집합 트리밍을 수행